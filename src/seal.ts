/************************************************
 SEAL: implemented in Typescript
 Original C code Copyright (c) 2024 Hacker Factor, Dr. Neal Krawetz
 Ported to TypeScript by Bertrand Gondouin (c) 2024
 See LICENSE & LICENSE-typescript
 ************************************************/

import { mediaAsset } from './mediaasset';
export { mediaAsset };

interface sealValidation {
  digest_ranges?: any[];
  digest_summary: string;
  error?: any[];
  digest1?: Uint8Array;
  digest2?: Uint8Array;
  signature_date?: string;
  signature?: string;
  signature_bytes: Uint8Array;
  signature_encoding: string;
}

interface sealAttributes {
  /**
   * This specifies a SEAL record version.
   * - This MUST be the first text in the TXT record.
   */
  seal: string; // 'seal_version',

  /**
   * The domain name containing the DNS TXT record for the SEAL public key.
   */
  d: string;

  /**
   * The asset's key algorithm.
   * - This must match the algorithm used to generate the key.
   * - For now, you can expect "rsa". For elliptic curve algorithms, use "ec".
   */
  ka: string;

  /**
   * This specifies the key version, in case you update the keys.
   * - When not specified, the default value is "1".
   * - The value can be any text string using the character set: `[A-Za-z0-9.+/-]` (letters, numbers, and limited punctuation; no spaces).
   */
  kv?: string;

  /**
   * The computed signature for the SEAL record.
   * - This MUST be last value in the SEAL record.
   * - If in binary format, the signature must not be quoted.
   * - If in base64 or hexadecimal format, the signature may be padded with spaces.
   */
  s: string;

  /**
           * The signature format. Possible values:
              - "hex": The signature is stored as a two-byte hexadecimal notation using lowercase letters [0-9a-f].
                  - Optional padding can use spaces (character 0x20) after the hexadecimal value.
              - "HEX": The signature is stored as a two-byte hexadecimal notation using uppercase letters [0-9A-F].
                  - Optional padding can use spaces (character 0x20) after the hexadecimal value.
              - "base64": The signature is stored as a base64-encoded value.
                  - Terminating "=" padding may be omitted.
                  - Optional padding can use spaces (character 0x20) after the base64 value. `base64` is the default encoding method if `sf=` is not specified.
              - "bin": The signature is stored as a raw binary data.
                  - This should only be used in file formats that support storing binary data. (This is also why the signature must always be the last element in the SEAL record. The binary signature ends when the SEAL record ends. Alternately, the `sl=` parameter can be used to specify the signature length.)
              - "date:" Any of the other formats may be preceded by the literal `date:`, such as `sf=date:hex`.
                  - This indicates that the signature begins with a timestamp in GMT YYYYMMDDhhmmss.
                  - The date is generated by the signer.
              - "date[0-9]:" Date with a number indicates the number of decimal points in the fraction of the date. This is used to specify subseconds.
                  - The number of decimal points identifies the accuracy of the timestamp. For example:
                      - date: may generate "20240326164401:" for 2024-03-26 16:44:01 GMT. The accuracy is +/- 0.5 seconds.
                      - date0: specifies no fractions and is the same as date.
                      - date1: specifies one decimal point, such as "20240326164401.5" and accuracy to within 0.05 seconds.
                      - date2: specifies one decimal point, such as "20240326164401.50" and accuracy to within 0.005 seconds.
                      - date3: specifies one decimal point, such as "20240326164401.500" and accuracy to within 0.0005 seconds.
           */
  sf?: string;

  /**
   * The digest algorithm.
   *  - This MUST be a NIST-approved algorithm. Current supported values are:
   *      - "sha256": The default value.
   *      - "sha512": For much longer digests.
   *      - "sha1": For shorter digests. (This algorithm is deprecated by NIST, but still widely used.)
   */
  da: string; //'digest_algorithm', The digest algorithm. This MUST be a NIST-approved algorithm.

  /**
   * The byte range to include in the digest.
   *  - This can be a complex field with sets of ranges *start*~*stop*, using tilda to denote the range deliminator.
   *  - Multiple ranges may be specified by commas.
   *  - Any literal character may be combined with simple arithmetic offsets.
   *  - For example: `b=F+4~S,s~f-20` This defines two ranges. The first begins 4 bytes into the file and ends at the start of the signature. The second begins after the signature and ends 20 bytes before the end of the file.
   */
  b?: string; // 'byte_range', The byte range to include in the digest

  /**
   * This specifies an optional unique identifier, such as a UUID or date.
   *  - The value is case-sensitive.
   *  - The uid permits different users at a domain to have many different keys.
   *  - The default value is an empty string: `uid=""`.
   */
  uid?: string; // 'unique_identifier', This specifies an optional unique identifier, such as a UUID or date. The value is case-sensitive.When not present, the default value is an empty string: uid=''.

  /**
   * A unique identifier identifying the signer's account or identity at the signing domain. When present, this impacts the signature generation.
   */
  id?: string; // 'identifier', A unique identifier identifying the signer's account or identity at the signing domain

  /**
   * Textual comment information.
   *  - Typically this is stored in another metadata field, such as EXIF, IPTC, or XMP. However, it can be included in the SEAL record.
   */
  info?: string; // 'seal_comment', Textual comment information.

  /**
   * Copyright information.
   *  - Copyright information is typically stored in another metadata field, such as EXIF, IPTC, or XMP. However, it can be included in the SEAL record.
   */
  copyright?: string;

  /**
   * The timestamp in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) (year-month-day) format denoting the revocation date in GMT.
   *  - All signatures after this date are treated as invalid, even if the public key validates the signature.
   *  - Use this when the key is revoked after a specific date. E.g.:
   *      - `r=2024-04-03T12:34:56`
   *      - `r="2024-04-03 12:34:56"`
   *      - `r=2024-04-03`.
   */
  r?: Date;

  /**
   * The base64-encoded public key.
   *  - Ending "=" in the base64 encoding may be omitted.
   *  - The value may include whitespace and double quotes. For example:
   *      - `p="abcdefg="` is the same as `p=abcdefg` is the same as `p="abc" "defg" "="`.
   *  - Double quotes and spaces are permitted because some DNS systems require breaks for long values.
   *  - The `p=` parameter MUST be the last field in the DNS TXT record.
   */
  p: string;

  /**
   * The signature length is typically optional.
   *  - The current supported algorithm (`ka=rsa`) does not require padding and uses a fixed-length, so `sl=` is unnecessary.
   *  - It is only required if:
   *      - padding is applied, If the signature contains any padding characters, then this field MUST be included to prevent tampering with the padding.
   *      - the length of a signature is variable
   *      - the length cannot be determined based on the SEAL record data storage.
   *  - The length MUST include whatever padding is required for storing the computed signature.
   *  - The signature algorithm (`ka=`) MUST know how to identify and handle padding.
   */
  sl?: string;
}

interface ECDSASigningAlgorithm {
  name: 'ECDSA';
  namedCurve: ECDSANamedCurve;
  hash: HashAlgorithm;
}

interface PKCSV1_5SigningAlgorithm {
  name: 'RSASSA-PKCS1-v1_5';
  hash: { name: HashAlgorithm };
}

type HashAlgorithm = 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512';

type ECDSANamedCurve = 'P-256' | 'P-384' | 'P-521';

type SigningAlgorithm = ECDSASigningAlgorithm | PKCSV1_5SigningAlgorithm;

const textEncoder = new TextEncoder();

type ErrorName =
  | 'HEX_STRING'
  | 'DNS_LOOKUP'
  | 'SEAL_RECORD_MISSING_PARAMETERS'
  | 'SEAL_RANGES'
  | 'KEY_IMPORT_ERROR'
  | 'DIGEST_MISSING'
  | 'VALIDATION_GENERAL_ERROR'
  | 'VALIDATION_MISSING_PARAMETERS'
  | 'SIGNATURE_MISSING'
  | 'SIGNATURE_FORMAT'
  | 'SIGNATURE_MISMATCH';

// Extend the built-in Error class to create a custom ValidationError class
export class ValidationError extends Error {
  name: ErrorName; // Specific type for error name
  cause?: any; // Optional cause of the error

  /**
   * Constructor to initialize ValidationError instance
   * @param name - The name of the error
   * @param message - The error message
   * @param cause - (Optional) The underlying cause of the error
   */
  constructor({ name, message, cause }: { name: ErrorName; message: string; cause?: any }) {
    super(message); // Call the parent class constructor with the message
    this.name = name;
    this.cause = cause;
  }
}
export class SEAL {
  public static public_keys: any = {};
  public static seals: any = [];
  public static record: sealAttributes;
  public static validation: sealValidation;

  /**
   * Parses the SEAL segment string in the asset and extracts parameters.
   *
   * @param asset - The asset object containing SEAL segments.
   */
  public static parse(asset: any) {
    // Start timing the parse operation
    console.time('parse');

    // Clean the SEAL segment string by removing tag characters
    // - Text: <seal ... />
    // - XML/SVG/HTML: <?seal ... ?>
    // - XMP: <*:seal>&lt;seal ... /&gt;</\*:seal>, <*:seal seal='&lt;seal .../&gt;' /> Where '*' is a namespace
    const sealSegmentString = asset.seal_segments[0].string
      .replace(/<.{0,1}seal /, '')
      .replace(/\?{0,1}\/>/, '')
      .replace(/&quot;/g, '"')
      .replace('<seal:seal>', '')
      .replace('/&', '')
      .replace('&lt;seal ', '');

    // Initialize the SEAL record object
    const sealRecord: any = {};

    // Regex pattern to match parameter key-value pairs
    const parameterPattern = / ?(.*?)=\"(.*?)\"/gm;
    let match: RegExpExecArray | null;

    // Extract parameters using the regex pattern
    while ((match = parameterPattern.exec(sealSegmentString)) !== null) {
      // Prevent infinite loops with the regex
      if (match.index === parameterPattern.lastIndex) {
        parameterPattern.lastIndex++;
      }
      // Map the parameter key-value pairs to the SEAL record object
      sealRecord[match[1]] = match[2];
    }

    if (!sealRecord.da) {
      sealRecord.da = 'sha256';
    }

    switch (sealRecord.da) {
      case 'sha256':
        sealRecord.da = 'SHA-256'; // 32 bytes
        break;
      case 'sha384':
        sealRecord.da = 'SHA-384'; // 48 bytes
        break;
      case 'sha512':
        sealRecord.da = 'SHA-512'; // 64 bytes
        break;
      case 'sha1':
        sealRecord.da = 'SHA-1'; // 20 bytes (This algorithm is deprecated by NIST, but still widely used, but don't use this in cryptographic applications)
        break;
      default:
        sealRecord.da = 'SHA-256';
        break;
    }

    // Validate that all required parameters are present
    if (sealRecord.seal && sealRecord.d && sealRecord.ka && sealRecord.s) {
      this.record = sealRecord;
    } else {
      throw new ValidationError({
        name: 'SEAL_RECORD_MISSING_PARAMETERS',
        message: 'The SEAL record is incomplete',
      });
    }

    // End timing the parse operation
    console.timeEnd('parse');
  }

  public static async validateSig(asset: any) {
    return new Promise(async (resolve, reject) => {
      this.validation = { digest_summary: '', signature_bytes: new Uint8Array(), signature_encoding: '' };

      let result_string;
      // DNS lookup if not in cache
      if (!this.public_keys[this.record.d]) {
        await this.getDNS(this.record.d, 'mozilla').catch((error) => {
          return reject(
            new ValidationError({
              name: 'DNS_LOOKUP',
              message: 'Querying DoH DNS for public key failed',
              cause: error,
            }),
          );
        });
      }

      await SEAL.digest(asset);
      await SEAL.doubleDigest();

      let algorithmParameters: SigningAlgorithm = this.getAlgorithmParameters(
        this.public_keys[this.record.d][this.record.ka].p,
        this.record.da,
        this.record.ka,
      );

      let cryptoKey = await SEAL.importCryptoKey(this.public_keys[this.record.d][this.record.ka].p, algorithmParameters);

      if (this.validation.digest2 && this.validation.signature && cryptoKey) {
        console.time('verifySignature');

        let result = await this.verifySignature(
          this.validation.digest2,
          this.validation.signature_bytes,
          cryptoKey,
          algorithmParameters,
        ).catch((error) => {
          reject(
            new ValidationError({
              name: 'VALIDATION_GENERAL_ERROR',
              message: "crypto.subtle.verify couldn't process the data",
              cause: error,
            }),
          );
        });
        console.timeEnd('verifySignature');

        //TODO: verbose flag
        if (result !== false) {
          result_string = `${asset.mimeType}:[${asset.filename}]\n✅ SEAL record #1 is valid.`;
        } else {
          result_string = `${asset.mimeType}:[${asset.filename}]\n⛔ SEAL record #1 is NOT valid.`;
        }

        if (this.validation.signature_date) {
          result_string = result_string + '\nDate: ' + createDate(this.validation.signature_date);
        }

        //calculated for the verbose summary
        this.validation.digest2 = new Uint8Array(await crypto.subtle.digest(this.record.da, this.validation.digest2));
        let key_length = this.getCryptoKeyLength(cryptoKey);

        let summary = `${result_string}
Signature Algorithm: ${this.record.ka.toUpperCase()}, ${key_length} bits
Digest Algorithm: ${this.record.da}
Digest: ${Array.from(this.validation.digest1 as Uint8Array)
          .map((bytes) => bytes.toString(16).padStart(2, '0'))
          .join('')}
Double Digest: ${Array.from(this.validation.digest2)
          .map((bytes) => bytes.toString(16).padStart(2, '0'))
          .join('')}
Signed Bytes: ${this.validation.digest_ranges}
Signature Spans: ${this.validation.digest_summary}
Signed By: ${this.record.d} for user ${this.record.id}
Copyright: ${this.record.copyright}
Comment: ${this.record.info}`;

        resolve({ result: result, summary: summary });
      } else {
        reject(
          new ValidationError({
            name: 'VALIDATION_MISSING_PARAMETERS',
            message: 'Double Digest or Signature is missing',
          }),
        );
      }
    });
  }

  /**
   * getDNS(): Given a hostname and a DoH provider, get SEAL keys from DNS.
   * Returns: Public key in 'public_keys', revoke in 'revoke'.
   * Errors are detailed in 'error'
   *
   * @static
   * @param {string} hostname
   * @param {string} [doh='cloudflare']
   * @return {*}  {Promise<string[]>}
   * @memberof SEAL
   */
  public static async getDNS(hostname: string, doh: string = 'cloudflare'): Promise<string[]> {
    console.time('getDNS_' + doh);

    return new Promise(async (resolve, reject) => {
      // Initialize the fetch URL and public keys object
      let fetchUrl: string;
      this.public_keys[hostname] = {};

      // Define DoH service providers
      const providers: { [key: string]: string } = {
        cloudflare: 'https://cloudflare-dns.com/dns-query',
        mozilla: 'https://mozilla.cloudflare-dns.com/dns-query',
        google: 'https://dns.googe/resolve',
      };

      // Construct the fetch URL based on the selected DoH provider
      fetchUrl = `${providers[doh]}?name=${hostname}&type=TXT`;

      // Initialize an array to store the public keys
      let publicKeys: string[] = [];

      // Fetch the DNS record and process the response
      let response: any = await fetch(fetchUrl, {
        method: 'GET',
        headers: {
          accept: 'application/dns-json',
        },
      }).catch((error) => {
        reject(error);
      });

      if (response) {
        try {
          let data = await response.json();

          // Process each record in the response
          data.Answer.forEach((record: any) => {
            let keyObject: any = {};

            // Check if the record contains SEAL data
            if (record.data.includes('seal')) {
              // Parse the SEAL data and store key-value pairs
              const keyElements = record.data.replace(/"/g, '').split(' ');
              keyElements.forEach((element: string) => {
                const keyValuePair = element.split('=');
                keyObject[keyValuePair[0]] = keyValuePair[1];
              });

              // Add the key object to the public keys array
              publicKeys.push(keyObject);
            }
          });

          // Categorize the keys based on the key algorithm
          publicKeys.forEach((key: any) => {
            if (key.ka === 'rsa') {
              this.public_keys[hostname].rsa = key;
            }
            if (key.ka === 'ec') {
              this.public_keys[hostname].ec = key;
            }
          });

          // End timing and resolve the promise with the public keys
          console.timeEnd('getDNS_' + doh);
        } catch (error) {
          console.timeEnd('getDNS_' + doh);
          reject(error);
        }

        resolve(this.public_keys[hostname]);
      }
    });
  }

  /**
   * digest(): Given a file, compute the digest!
   * Computes the digest and stores binary data in @digest1.
   * Stores the byte range in 'digest_range'.
   * Sets 'digest_summary' to store summaries of range
   * Any error messages are stored in error.
   * @private
   * @static
   * @memberof SEAL
   */
  private static async digest(asset: any): Promise<void> {
    return new Promise(async (resolve, reject) => {
      console.time('digest');
      // Digest ranges mapping
      this.validation.digest_ranges = [];

      let show_range_start: String;
      let show_range_stop: String;

      if (this.record.b) {
        let digest_ranges = this.record.b.split(',');
        digest_ranges.forEach((digest_range) => {
          let start;
          let stop;
          [start, stop] = digest_range.split('~');

          let sub: any = start.split('-');
          let add: any = start.split('+');

          if (sub[1]) {
            start = sub[0];
            sub = parseInt(sub[1]);
          } else {
            sub = 0;
          }

          if (add[1]) {
            start = add[0];
            add = parseInt(add[1]);
          } else {
            add = 0;
          }

          switch (start) {
            case 'F':
              start = 0;
              if (!show_range_start) {
                show_range_start = 'Start of file';
              }
              break;
            case 'f':
              start = asset.getDataLength();
              if (!show_range_start) {
                show_range_start = 'End of file';
              }
              break;
            case 'S':
              start = asset.seal_segments[0].signature_end - this.record.s.length;
              if (!show_range_start) {
                show_range_start = 'Start of signature';
              }
              break;
            case 's':
              start = asset.seal_segments[0].signature_end;
              if (!show_range_start) {
                show_range_start = 'End of signature';
              }
              break;
            case 'P':
              start = 0; // to do
              break;
            case 'p':
              start = 0; // to do
              break;
            default:
              reject(
                new ValidationError({
                  name: 'SEAL_RANGES',
                  message: 'ranges start error',
                }),
              );
              break;
          }
          start = start + add + sub;

          sub = stop.split('-');
          add = stop.split('+');

          if (sub[1]) {
            stop = sub[0];
            sub = parseInt(sub[1]);
          } else {
            sub = 0;
          }

          if (add[1]) {
            stop = add[0];
            add = parseInt(add[1]);
          } else {
            add = 0;
          }

          switch (stop) {
            case 'F':
              stop = 0;
              show_range_stop = 'Start of file';
              break;
            case 'f':
              stop = asset.getDataLength();
              show_range_stop = 'End of file';
              break;
            case 'S':
              stop = asset.seal_segments[0].signature_end - this.record.s.length;
              show_range_stop = 'start of signature';
              break;
            case 's':
              stop = asset.seal_segments[0].signature_end;
              show_range_stop = 'end of signature';
              break;
            case 'P':
              stop = 0; // to do
              break;
            case 'p':
              stop = 0; // to do
              break;
            default:
              reject(
                new ValidationError({
                  name: 'SEAL_RANGES',
                  message: 'ranges stop error',
                }),
              );
              break;
          }

          stop = stop + add + sub;
          this.validation.digest_ranges?.push([start, stop]);
          this.validation.digest_summary = `${show_range_start} to ${show_range_stop}`;
        });

        crypto.subtle.digest(this.record.da, asset.assembleBuffer(this.validation.digest_ranges)).then((digest) => {
          this.validation.digest1 = new Uint8Array(digest);
          console.timeEnd('digest');
          resolve();
        });
      }
    });
  }

  /**
   * If there's a date or id (user_id), then add them to the digest.
   * This uses binary 'digest1', 'id', 'signature_date', and 'da'.
   * Computes the digest and places new data in digest2.
   * Any error messages are stored in error.
   *
   * @private
   * @static
   * @memberof SEAL
   */
  private static doubleDigest(): Promise<void> {
    return new Promise(async (resolve, reject) => {
      console.time('doubleDigest');
      let signature_formats: string[] = [];

      if (this.record.sf) {
        signature_formats = this.record.sf.split(':');
      }

      if (this.record.s) {
        this.validation.signature = this.record.s;

        try {
          if (signature_formats.length > 0) {
            signature_formats.forEach((format: string) => {
              if (format == 'base64' || format == 'hex' || format == 'HEX' || format == 'bin') {
                this.validation.signature_encoding = format;
                if (this.validation.signature) this.validation.signature = this.validation.signature.replace(format + ':', '');
              }

              if (format.includes('date')) {
                let accuracy = parseInt(format.charAt(format.length - 1));
                if (isNaN(accuracy)) {
                  this.validation.signature = this.record.s.substring(15, this.record.s.length);
                  accuracy = 0;
                } else {
                  this.validation.signature = this.record.s.substring(16 + accuracy, this.record.s.length);
                }
                this.validation.signature_date = this.record.s.substring(0, 15 + accuracy);
              }
            });
          } else {
            // Default
            this.validation.signature_encoding = 'base64';
          }
          if (this.validation.signature_encoding == 'hex' || this.validation.signature_encoding == 'HEX') {
            this.validation.signature_bytes = hexToUint8Array(this.validation.signature);
          }

          if (this.validation.signature_encoding == 'base64') {
            this.validation.signature_bytes = base64ToUint8Array(this.validation.signature);
          }
        } catch (error) {
          reject(
            new ValidationError({
              name: 'SIGNATURE_FORMAT',
              message: 'The signature format is not valid or corrupted',
            }),
          );
        }
      } else {
        reject(
          new ValidationError({
            name: 'SIGNATURE_MISSING',
            message: 'The signature is missing',
          }),
        );
      }

      let prepend: string = '';

      if (this.validation.signature_date) {
        prepend = this.validation.signature_date + ':';
      }
      if (this.record.id) {
        prepend = prepend + this.record.id + ':';
      }

      let prepend_buffer: Uint8Array = textEncoder.encode(prepend);

      if (this.validation.digest1) {
        //Note crypto.subtle.verify does the hashing!
        this.validation.digest2 = mergeBuffer(prepend_buffer, this.validation.digest1);

        console.timeEnd('doubleDigest');
        resolve();
      } else {
        reject(
          new ValidationError({
            name: 'DIGEST_MISSING',
            message: 'The digest is missing',
          }),
        );
      }
    });
  }

  private static getAlgorithmParameters(publicKey: string, digestAlgorithm: string, keyAlgorithm: string): SigningAlgorithm {
    let algorithmParameters: SigningAlgorithm;

    let hash: HashAlgorithm = digestAlgorithm as HashAlgorithm;

    if (keyAlgorithm == 'rsa') {
      algorithmParameters = {
        name: 'RSASSA-PKCS1-v1_5',
        hash: { name: hash },
      };
    } else if (keyAlgorithm == 'ec') {
      let named_curve: ECDSANamedCurve;
      switch (publicKey.length) {
        case 91:
          named_curve = 'P-256'; // Assuming ECDSA P-256: 91 bytes
          break;
        case 120:
          named_curve = 'P-384'; // Assuming ECDSA P-384: 120 bytes
          break;
        case 156:
          named_curve = 'P-521'; // Assuming ECDSA P-521: 156 bytes
          break;
        default:
          named_curve = 'P-256';
          break;
      }

      algorithmParameters = {
        name: 'ECDSA',
        hash: hash,
        namedCurve: named_curve,
      };
    } else {
      algorithmParameters = {
        name: 'RSASSA-PKCS1-v1_5',
        hash: { name: hash },
      };
    }
    return algorithmParameters;
  }

  private static getCryptoKeyLength(key: CryptoKey) {
    let keyLength;
    if (key.algorithm.name === 'ECDSA') {
      keyLength = parseInt(key.algorithm.namedCurve.replace('P-', ''));
    }
    if (key.algorithm.name === 'RSASSA-PKCS1-v1_5') {
      keyLength = key.algorithm.modulusLength;
    }
    return keyLength;
  }

  /**
   * Imports a public key for use in cryptographic operations.
   *
   * @param {string} publicKey - The base64-encoded public key string.
   * @param {SigningAlgorithm} algorithmParameters - The parameters of the cryptographic algorithm to use.
   * @returns {Promise<CryptoKey>} - A promise that resolves to the imported CryptoKey.
   * @throws {ValidationError} - If the key import process fails.
   */
  private static async importCryptoKey(publicKey: string, algorithmParameters: SigningAlgorithm): Promise<CryptoKey> {
    return new Promise(async (resolve, reject) => {
      const key = await crypto.subtle
        .importKey('spki', base64ToUint8Array(publicKey), algorithmParameters, true, ['verify'])
        .catch((error) => {
          reject(
            new ValidationError({
              name: 'KEY_IMPORT_ERROR',
              message: "crypto.subtle.importKey couldn't process the data",
              cause: error,
            }),
          );
        });
      resolve(key as CryptoKey);
    });
  }

  /**
   * Verifies the digital signature of the given payload using the provided cryptographic key and algorithm parameters.
   *
   * @param {Uint8Array} payload - The data payload to verify the signature against.
   * @param {Uint8Array} signature - The digital signature to verify.
   * @param {CryptoKey} cryptoKey - The cryptographic key used for verification.
   * @param {SigningAlgorithm} algorithmParameters - The parameters of the cryptographic algorithm to use.
   * @returns {Promise<boolean>} - A promise that resolves to true if the signature is valid, false otherwise.
   */
  private static async verifySignature(
    payload: Uint8Array,
    signature: Uint8Array,
    cryptoKey: CryptoKey,
    algorithmParameters: SigningAlgorithm,
  ): Promise<boolean> {
    // Convert ECDSA signature from ASN.1 representation to IEEE P1363 representation
    if (cryptoKey.algorithm.name === 'ECDSA') {
      signature = convertEcdsaAsn1Signature(signature);
    }
    // Verify the signature using the SubtleCrypto API and return the result
    return crypto.subtle.verify(algorithmParameters, cryptoKey, signature, payload);
  }
}

/**
 * Converts a Base64-encoded string to an Uint8Array.
 *
 * @param base64 - The Base64-encoded string to convert.
 * @returns The resulting Uint8Array.
 */
function base64ToUint8Array(base64: string): Uint8Array {
  // Decode the Base64-encoded string into a binary string
  const binaryString: string = atob(base64);

  // Create a Uint8Array to hold the decoded bytes
  const byteArray: Uint8Array = new Uint8Array(binaryString.length);

  // Convert each character in the binary string to a byte in the Uint8Array
  for (let i = 0; i < binaryString.length; i++) {
    byteArray[i] = binaryString.charCodeAt(i);
  }

  // Return the Uint8Array
  return byteArray;
}

/**
 * Converts a hex string to an Uint8Array.
 *
 * @param hex - The hex string to convert.
 * @returns The resulting Uint8Array.
 */
function hexToUint8Array(hex: string): Uint8Array {
  // Ensure the hex string has an even length
  if (hex.length % 2 !== 0) {
    throw new ValidationError({
      name: 'HEX_STRING',
      message: 'Hex string must have an even length',
    });
  }

  // Create a Uint8Array to hold the bytes
  const bytes = new Uint8Array(hex.length / 2);

  // Convert each pair of hex characters to a byte
  for (let i: number = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }

  // Return the the Uint8Array
  return bytes;
}

/**
 * Concatenate two ArrayBuffers.
 *
 * @param buffer1 - The first ArrayBuffer to concatenate.
 * @param buffer2 - The second ArrayBuffer to concatenate.
 * @returns A new ArrayBuffer containing the concatenated data of buffer1 and buffer2.
 */
function mergeBuffer(buffer1: Uint8Array, buffer2: Uint8Array): Uint8Array {
  // If buffer1 is null or undefined, return buffer2
  if (!buffer1) {
    return buffer2;
  }
  // If buffer2 is null or undefined, return buffer1
  else if (!buffer2) {
    return buffer1;
  }

  // Create a new Uint8Array to hold the concatenated data
  const concatenatedBuffer = new Uint8Array(buffer1.byteLength + buffer2.byteLength);

  // Set the data from buffer1 into the new Uint8Array
  concatenatedBuffer.set(buffer1, 0);

  // Set the data from buffer2 into the new Uint8Array, starting at the end of buffer1's data
  concatenatedBuffer.set(buffer2, buffer1.byteLength);

  // Return the ArrayBuffer representation of the concatenated Uint8Array
  return concatenatedBuffer;
}

/**
 * Creates a Date object from a string in the format YYYYMMDDHHMMSS.sssssssss.
 *
 * @param dateString - The input date string in the format YYYYMMDDHHMMSS.sssssssss.
 * @returns A Date object representing the input date and time.
 */
function createDate(dateString: string): Date {
  // Regular expression to match the components of the date string
  const datePattern = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})\.(\d{0,9})/;

  // Replace the matched components with the format required by the Date constructor
  const formattedDateString = dateString.replace(datePattern, '$1-$2-$3T$4:$5:$6.$7Z');

  // Create and return a new Date object using the formatted date string
  return new Date(formattedDateString);
}

/**
 * Converts an ECDSA ASN.1 signature into a raw format.
 * ref: https://www.criipto.com/blog/webauthn-ecdsa-signature
 *
 * @param {Uint8Array} input - The input buffer containing the ASN.1 signature.
 * @returns {Uint8Array} - The converted raw ECDSA signature.
 * @throws {Error} - If the input does not contain exactly 2 ASN.1 sequence elements,
 *                   or if there are length inconsistencies in the R and S values.
 */
function convertEcdsaAsn1Signature(input: Uint8Array): Uint8Array {
  // Read the ASN.1 integer sequence elements from the input.
  const elements = readAsn1IntegerSequence(input);
  if (elements.length !== 2) throw new Error('Expected 2 ASN.1 sequence elements');
  let [r, s] = elements;

  // R and S length is assumed to be a multiple of 128 bits (16 bytes).
  // If the leading byte is 0 and the length modulo 16 is 1,
  // the leading 0 is for two's complement and will be removed.
  if (r[0] === 0 && r.byteLength % 16 == 1) {
    r = r.slice(1);
  }
  if (s[0] === 0 && s.byteLength % 16 == 1) {
    s = s.slice(1);
  }

  // If R and S length is missing a byte (length % 16 == 15),
  // pad the value with a leading 0.
  if (r.byteLength % 16 == 15) {
    r = new Uint8Array(mergeBuffer(new Uint8Array([0]), r));
  }
  if (s.byteLength % 16 == 15) {
    s = new Uint8Array(mergeBuffer(new Uint8Array([0]), s));
  }

  // If R and S length is still not a multiple of 128 bits, throw an error.
  if (r.byteLength % 16 != 0) throw new Error('unknown ECDSA sig r length error');
  if (s.byteLength % 16 != 0) throw new Error('unknown ECDSA sig s length error');

  // Merge the R and S values into a single buffer and return it.
  return mergeBuffer(r, s);
}

/**
 * Reads an ASN.1 integer sequence from the input Uint8Array.
 *
 * @param {Uint8Array} input - The input buffer containing the ASN.1 sequence.
 * @returns {Uint8Array[]} - An array of Uint8Array elements representing the integers in the sequence.
 * @throws {Error} - If the input is not a valid ASN.1 sequence or if an element is not an INTEGER.
 */
function readAsn1IntegerSequence(input: Uint8Array): Uint8Array[] {
  // Check if the input starts with the ASN.1 SEQUENCE tag (0x30).
  if (input[0] !== 0x30) throw new Error('Input is not an ASN.1 sequence');

  // Get the length of the sequence.
  const seqLength = input[1];
  const elements: Uint8Array[] = [];

  // Slice the input to get the sequence content.
  let current = input.slice(2, 2 + seqLength);

  // Loop through the sequence content to extract INTEGER elements.
  while (current.length > 0) {
    const tag = current[0];

    // Check if the tag is the ASN.1 INTEGER tag (0x02).
    if (tag !== 0x02) throw new Error('Expected ASN.1 sequence element to be an INTEGER');

    // Get the length of the INTEGER element.
    const elLength = current[1];

    // Push the INTEGER element into the elements array.
    elements.push(current.slice(2, 2 + elLength));

    // Slice the current buffer to process the next element.
    current = current.slice(2 + elLength);
  }

  // Return the array of INTEGER elements.
  return elements;
}
