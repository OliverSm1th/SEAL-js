/************************************************
 SEAL: implemented in Typescript
 Original C code Copyright (c) 2024 Hacker Factor, Dr. Neal Krawetz
 Ported to TypeScript by Bertrand Gondouin (c) 2024
 See LICENSE & LICENSE-typescript
 ************************************************/

import { mediaAsset } from './mediaasset.js';
export { mediaAsset };
interface sealValidation {
  digest_ranges?: any[];
  digest_summary: string;
  error?: any[];
  digest1?: ArrayBuffer;
  digest2?: ArrayBuffer;
  signature_date?: string;
  signature?: string | ArrayBuffer;
  signature_encoding: string;
}

interface sealAttributes {
  /**
   * This specifies a SEAL record version.
   * - This MUST be the first text in the TXT record.
   */
  seal: string; // 'seal_version',

  /**
   * The domain name containing the DNS TXT record for the SEAL public key.
   */
  d: string;

  /**
   * The asset's key algorithm.
   * - This must match the algorithm used to generate the key.
   * - For now, you can expect "rsa". For elliptic curve algorithms, use "ec".
   */
  ka: string;

  /**
   * This specifies the key version, in case you update the keys.
   * - When not specified, the default value is "1".
   * - The value can be any text string using the character set: `[A-Za-z0-9.+/-]` (letters, numbers, and limited punctuation; no spaces).
   */
  kv?: string;

  /**
   * The computed signature for the SEAL record.
   * - This MUST be last value in the SEAL record.
   * - If in binary format, the signature must not be quoted.
   * - If in base64 or hexadecimal format, the signature may be padded with spaces.
   */
  s: string;

  /**
           * The signature format. Possible values:
              - "hex": The signature is stored as a two-byte hexadecimal notation using lowercase letters [0-9a-f].
                  - Optional padding can use spaces (character 0x20) after the hexadecimal value.
              - "HEX": The signature is stored as a two-byte hexadecimal notation using uppercase letters [0-9A-F].
                  - Optional padding can use spaces (character 0x20) after the hexadecimal value.
              - "base64": The signature is stored as a base64-encoded value.
                  - Terminating "=" padding may be omitted.
                  - Optional padding can use spaces (character 0x20) after the base64 value. `base64` is the default encoding method if `sf=` is not specified.
              - "bin": The signature is stored as a raw binary data.
                  - This should only be used in file formats that support storing binary data. (This is also why the signature must always be the last element in the SEAL record. The binary signature ends when the SEAL record ends. Alternately, the `sl=` parameter can be used to specify the signature length.)
              - "date:" Any of the other formats may be preceded by the literal `date:`, such as `sf=date:hex`.
                  - This indicates that the signature begins with a timestamp in GMT YYYYMMDDhhmmss.
                  - The date is generated by the signer.
              - "date[0-9]:" Date with a number indicates the number of decimal points in the fraction of the date. This is used to specify subseconds.
                  - The number of decimal points identifies the accuracy of the timestamp. For example:
                      - date: may generate "20240326164401:" for 2024-03-26 16:44:01 GMT. The accuracy is +/- 0.5 seconds.
                      - date0: specifies no fractions and is the same as date.
                      - date1: specifies one decimal point, such as "20240326164401.5" and accuracy to within 0.05 seconds.
                      - date2: specifies one decimal point, such as "20240326164401.50" and accuracy to within 0.005 seconds.
                      - date3: specifies one decimal point, such as "20240326164401.500" and accuracy to within 0.0005 seconds.
           */
  sf?: string;

  /**
   * The digest algorithm.
   *  - This MUST be a NIST-approved algorithm. Current supported values are:
   *      - "sha256": The default value.
   *      - "sha512": For much longer digests.
   *      - "sha1": For shorter digests. (This algorithm is deprecated by NIST, but still widely used.)
   */
  da?: string; //'digest_algorithm', The digest algorithm. This MUST be a NIST-approved algorithm.

  /**
   * The byte range to include in the digest.
   *  - This can be a complex field with sets of ranges *start*~*stop*, using tilda to denote the range deliminator.
   *  - Multiple ranges may be specified by commas.
   *  - Any literal character may be combined with simple arithmetic offsets.
   *  - For example: `b=F+4~S,s~f-20` This defines two ranges. The first begins 4 bytes into the file and ends at the start of the signature. The second begins after the signature and ends 20 bytes before the end of the file.
   */
  b?: string; // 'byte_range', The byte range to include in the digest

  /**
   * This specifies an optional unique identifier, such as a UUID or date.
   *  - The value is case-sensitive.
   *  - The uid permits different users at a domain to have many different keys.
   *  - The default value is an empty string: `uid=""`.
   */
  uid?: string; // 'unique_identifier', This specifies an optional unique identifier, such as a UUID or date. The value is case-sensitive.When not present, the default value is an empty string: uid=''.

  /**
   * A unique identifier identifying the signer's account or identity at the signing domain. When present, this impacts the signature generation.
   */
  id?: string; // 'identifier', A unique identifier identifying the signer's account or identity at the signing domain

  /**
   * Textual comment information.
   *  - Typically this is stored in another metadata field, such as EXIF, IPTC, or XMP. However, it can be included in the SEAL record.
   */
  info?: string; // 'seal_comment', Textual comment information.

  /**
   * Copyright information.
   *  - Copyright information is typically stored in another metadata field, such as EXIF, IPTC, or XMP. However, it can be included in the SEAL record.
   */
  copyright?: string;

  /**
   * The timestamp in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) (year-month-day) format denoting the revocation date in GMT.
   *  - All signatures after this date are treated as invalid, even if the public key validates the signature.
   *  - Use this when the key is revoked after a specific date. E.g.:
   *      - `r=2024-04-03T12:34:56`
   *      - `r="2024-04-03 12:34:56"`
   *      - `r=2024-04-03`.
   */
  r?: Date;

  /**
   * The base64-encoded public key.
   *  - Ending "=" in the base64 encoding may be omitted.
   *  - The value may include whitespace and double quotes. For example:
   *      - `p="abcdefg="` is the same as `p=abcdefg` is the same as `p="abc" "defg" "="`.
   *  - Double quotes and spaces are permitted because some DNS systems require breaks for long values.
   *  - The `p=` parameter MUST be the last field in the DNS TXT record.
   */
  p: string;

  /**
   * The signature length is typically optional.
   *  - The current supported algorithm (`ka=rsa`) does not require padding and uses a fixed-length, so `sl=` is unnecessary.
   *  - It is only required if:
   *      - padding is applied, If the signature contains any padding characters, then this field MUST be included to prevent tampering with the padding.
   *      - the length of a signature is variable
   *      - the length cannot be determined based on the SEAL record data storage.
   *  - The length MUST include whatever padding is required for storing the computed signature.
   *  - The signature algorithm (`ka=`) MUST know how to identify and handle padding.
   */
  sl?: string;
}

const textEncoder = new TextEncoder();

type ErrorName =
  | 'HEX_STRING'
  | 'DNS_LOOKUP'
  | 'SEAL_RECORD_MISSING_PARAMETERS'
  | 'KEY_IMPORT_ERROR'
  | 'DIGEST_MISSING'
  | 'VALIDATION_GENERAL_ERROR'
  | 'VALIDATION_MISSING_PARAMETERS'
  | 'SIGNATURE_MISSING'
  | 'SIGNATURE_FORMAT'
  | 'SIGNATURE_MISMATCH';

// Extend the built-in Error class to create a custom ValidationError class
export class ValidationError extends Error {
  name: ErrorName; // Specific type for error name
  cause?: any; // Optional cause of the error

  /**
   * Constructor to initialize ValidationError instance
   * @param name - The name of the error
   * @param message - The error message
   * @param cause - (Optional) The underlying cause of the error
   */
  constructor({ name, message, cause }: { name: ErrorName; message: string; cause?: any }) {
    super(message); // Call the parent class constructor with the message
    this.name = name;
    this.cause = cause;
  }
}
export class SEAL {
  public static public_keys: any = {};
  public static seals: any = [];
  public static record: sealAttributes;
  public static validation: sealValidation;

  /**
   * Parses the SEAL segment string in the asset and extracts parameters.
   *
   * @param asset - The asset object containing SEAL segments.
   */
  public static parse(asset: any) {
    // Start timing the parse operation
    console.time('parse');

    // Clean the SEAL segment string by removing tag characters
    // - Text: <seal ... />
    // - XML/SVG/HTML: <?seal ... ?>
    // - XMP: <*:seal>&lt;seal ... /&gt;</\*:seal>, <*:seal seal='&lt;seal .../&gt;' /> Where '*' is a namespace
    const sealSegmentString = asset.seal_segments[0].string
      .replace(/<.{0,1}seal /, '')
      .replace(/\?{0,1}\/>/, '')
      .replace(/&quot;/g, '"')
      .replace('<seal:seal>', '')
      .replace('/&', '')
      .replace('&lt;seal ', '');

    // Initialize the SEAL record object
    const sealRecord: any = {};

    // Regex pattern to match parameter key-value pairs
    const parameterPattern = / ?(.*?)=\"(.*?)\"/gm;
    let match: RegExpExecArray | null;

    // Extract parameters using the regex pattern
    while ((match = parameterPattern.exec(sealSegmentString)) !== null) {
      // Prevent infinite loops with the regex
      if (match.index === parameterPattern.lastIndex) {
        parameterPattern.lastIndex++;
      }
      // Map the parameter key-value pairs to the SEAL record object
      sealRecord[match[1]] = match[2];
    }

    // Validate that all required parameters are present
    if (sealRecord.seal && sealRecord.d && sealRecord.ka && sealRecord.s) {
      this.record = sealRecord;
    } else {
      throw new ValidationError({
        name: 'SEAL_RECORD_MISSING_PARAMETERS',
        message: 'The SEAL record is incomplete',
      });
    }

    // End timing the parse operation
    console.timeEnd('parse');
  }

  /**
   * getDNS(): Given a hostname and a DoH provider, get SEAL keys from DNS.
   * Returns: Public key in 'public_keys', revoke in 'revoke'.
   * Errors are detailed in 'error'
   *
   * @static
   * @param {string} hostname
   * @param {string} [doh='cloudflare']
   * @return {*}  {Promise<string[]>}
   * @memberof SEAL
   */
  public static async getDNS(hostname: string, doh: string = 'cloudflare'): Promise<string[]> {
    console.time('getDNS_' + doh);

    return new Promise(async (resolve, reject) => {
      // Initialize the fetch URL and public keys object
      let fetchUrl: string;
      this.public_keys[hostname] = {};

      // Define DoH service providers
      const providers: { [key: string]: string } = {
        cloudflare: 'https://cloudflare-dns.com/dns-query',
        mozilla: 'https://mozilla.cloudflare-dns.com/dns-query',
        google: 'https://dns.googe/resolve',
      };

      // Construct the fetch URL based on the selected DoH provider
      fetchUrl = `${providers[doh]}?name=${hostname}&type=TXT`;

      // Initialize an array to store the public keys
      let publicKeys: string[] = [];

      // Fetch the DNS record and process the response
      let response: any = await fetch(fetchUrl, {
        method: 'GET',
        headers: {
          accept: 'application/dns-json',
        },
      }).catch((error) => {
        reject(error);
      });

      if (response) {
        try {
          let data = await response.json();

          // Process each record in the response
          data.Answer.forEach((record: any) => {
            let keyObject: any = {};

            // Check if the record contains SEAL data
            if (record.data.includes('seal')) {
              // Parse the SEAL data and store key-value pairs
              const keyElements = record.data.replace(/"/g, '').split(' ');
              keyElements.forEach((element: string) => {
                const keyValuePair = element.split('=');
                keyObject[keyValuePair[0]] = keyValuePair[1];
              });

              // Add the key object to the public keys array
              publicKeys.push(keyObject);
            }
          });

          // Categorize the keys based on the key algorithm
          publicKeys.forEach((key: any) => {
            if (key.ka === 'rsa') {
              this.public_keys[hostname].rsa = key;
            }
            if (key.ka === 'ec') {
              this.public_keys[hostname].ec = key;
            }
          });

          // End timing and resolve the promise with the public keys
          console.timeEnd('getDNS_' + doh);
        } catch (error) {
          console.timeEnd('getDNS_' + doh);
          reject(error);
        }

        resolve(this.public_keys[hostname]);
      }
    });
  }

  /**
   * Imports a public key from a PEM-encoded string.
   *
   * @param pem - The PEM-encoded public key.
   * @param keyAlgorithm - The key algorithm ('rsa' or 'ec').
   * @returns A promise that resolves to the imported CryptoKey.
   */
  public static async importPublicKey(pem: string, keyAlgorithm: string): Promise<CryptoKey> {
    console.time('importPublicKey');

    return new Promise(async (resolve, reject) => {
      let algorithmParams;

      // Define the algorithm parameters based on the key algorithm
      if (keyAlgorithm === 'rsa') {
        algorithmParams = {
          name: 'RSASSA-PKCS1-v1_5',
          hash: {
            name: 'SHA-256', // TODO: Add handling for different key sizes
          },
        };
      } else if (keyAlgorithm === 'ec') {
        algorithmParams = {
          name: 'ECDSA',
          namedCurve: 'P-256', // TODO: Replace with the appropriate curve name
        };
      }

      // Convert the PEM-encoded key to an ArrayBuffer
      const keyData: ArrayBuffer = base64ToArrayBuffer(pem);

      // Import the public key using the SubtleCrypto API
      await crypto.subtle
        .importKey(
          'spki', // The format of the key
          keyData, // The key data
          algorithmParams, // The algorithm parameters
          true, // Whether the key is extractable
          ['verify'], // The key usage
        )
        .then((publicKey) => {
          resolve(publicKey);
        })
        .catch((error) => {
          if (keyAlgorithm === 'rsa') {
            reject('RSA: ' + error.message);
          }
          reject(error.message);
          if (keyAlgorithm === 'ec') {
            reject('EC: ' + error.message);
          }
        });

      console.timeEnd('importPublicKey');
    });
  }

  /**
   * digest(): Given a file, compute the digest!
   * Computes the digest and stores binary data in @digest1.
   * Stores the byte range in 'digest_range'.
   * Sets 'digest_summary' to store summaries of range
   * Any error messages are stored in error.
   * @private
   * @static
   * @memberof SEAL
   */
  private static async digest(asset: any): Promise<void> {
    return new Promise(async (resolve) => {
      console.time('digest');
      // Digest ranges mapping
      this.validation.digest_ranges = [];

      let show_range_start: String;
      let show_range_stop: String;

      if (this.record.b) {
        let digest_ranges = this.record.b.split(',');
        digest_ranges.forEach((digest_range) => {
          let start;
          let stop;
          [start, stop] = digest_range.split('~');

          let sub: any = start.split('-');
          let add: any = start.split('+');

          if (sub[1]) {
            start = sub[0];
            sub = parseInt(sub[1]);
          } else {
            sub = 0;
          }

          if (add[1]) {
            start = add[0];
            add = parseInt(add[1]);
          } else {
            add = 0;
          }

          switch (start) {
            case 'F':
              start = 0;
              if (!show_range_start) {
                show_range_start = 'Start of file';
              }
              break;
            case 'f':
              start = asset.getDataLength();
              if (!show_range_start) {
                show_range_start = 'End of file';
              }
              break;
            case 'S':
              start = asset.seal_segments[0].signature_end - this.record.s.length;
              if (!show_range_start) {
                show_range_start = 'Start of signature';
              }
              break;
            case 's':
              start = asset.seal_segments[0].signature_end;
              if (!show_range_start) {
                show_range_start = 'End of signature';
              }
              break;
            case 'P':
              start = 0; // to do
              break;
            case 'p':
              start = 0; // to do
              break;
            default:
              console.error('ranges start error');
              break;
          }
          start = start + add + sub;

          sub = stop.split('-');
          add = stop.split('+');

          if (sub[1]) {
            stop = sub[0];
            sub = parseInt(sub[1]);
          } else {
            sub = 0;
          }

          if (add[1]) {
            stop = add[0];
            add = parseInt(add[1]);
          } else {
            add = 0;
          }

          switch (stop) {
            case 'F':
              stop = 0;
              show_range_stop = 'Start of file';
              break;
            case 'f':
              stop = asset.getDataLength();
              show_range_stop = 'End of file';
              break;
            case 'S':
              stop = asset.seal_segments[0].signature_end - this.record.s.length;
              show_range_stop = 'start of signature';
              break;
            case 's':
              stop = asset.seal_segments[0].signature_end;
              show_range_stop = 'end of signature';
              break;
            case 'P':
              stop = 0; // to do
              break;
            case 'p':
              stop = 0; // to do
              break;
            default:
              console.error('ranges start error');
              break;
          }

          stop = stop + add + sub;
          this.validation.digest_ranges?.push([start, stop]);
          this.validation.digest_summary = `${show_range_start} to ${show_range_stop}`;
        });

        this.validation.digest1 = await SEAL._digest(asset.assembleBuffer(this.validation.digest_ranges), this.record.da);
        console.timeEnd('digest');
        resolve();
      }
    });
  }

  /**
   * If there's a date or id (user_id), then add them to the digest.
   * This uses binary 'digest1', 'id', 'signature_date', and 'da'.
   * Computes the digest and places new data in digest2.
   * Any error messages are stored in error.
   *
   * @private
   * @static
   * @memberof SEAL
   */
  private static doubleDigest(): Promise<void> {
    return new Promise(async (resolve, reject) => {
      console.time('doubleDigest');
      let signature_formats: string[] = [];

      if (this.record.sf) {
        signature_formats = this.record.sf.split(':');
      }

      if (this.record.s) {
        this.validation.signature = this.record.s;

        try {
          if (signature_formats.length > 0) {
            signature_formats.forEach((format: string) => {
              if (format == 'base64' || format == 'hex' || format == 'HEX' || format == 'bin') {
                this.validation.signature_encoding = format;
                this.validation.signature = this.validation.signature.replace(format + ':', '');
              }

              if (format.includes('date')) {
                let accuracy = parseInt(format.charAt(format.length - 1));
                if (isNaN(accuracy)) {
                  this.validation.signature = this.record.s.substring(15, this.record.s.length);
                  accuracy = 0;
                } else {
                  this.validation.signature = this.record.s.substring(16 + accuracy, this.record.s.length);
                }
                this.validation.signature_date = this.record.s.substring(0, 15 + accuracy);
              }
            });
          } else {
            // Default
            this.validation.signature_encoding = 'base64';
          }

          if (this.validation.signature_encoding == 'hex' || this.validation.signature_encoding == 'HEX') {
            this.validation.signature = hexToArrayBuffer(this.validation.signature);
          }

          if (this.validation.signature_encoding == 'base64') {
            this.validation.signature = base64ToArrayBuffer(this.validation.signature);
          }
        } catch (error) {
          reject(
            new ValidationError({
              name: 'SIGNATURE_FORMAT',
              message: 'The signature format is not valid or corrupted',
            }),
          );
        }
      } else {
        reject(
          new ValidationError({
            name: 'SIGNATURE_MISSING',
            message: 'The signature is missing',
          }),
        );
      }

      let prepend: string = '';

      if (this.validation.signature_date) {
        prepend = this.validation.signature_date + ':';
      }
      if (this.record.id) {
        prepend = prepend + this.record.id + ':';
      }

      let prepend_buffer: ArrayBuffer = textEncoder.encode(prepend).buffer;

      if (this.validation.digest1) {
        //Note crypto.subtle.verify does the hashing!
        this.validation.digest2 = concatArrayBuffers(prepend_buffer, this.validation.digest1); // working with sha-256
        console.timeEnd('doubleDigest');
        resolve();
      } else {
        reject(
          new ValidationError({
            name: 'DIGEST_MISSING',
            message: 'The digest is missing',
          }),
        );
      }
    });
  }

  public static async validateSig(asset: any) {
    console.time('validateSig');
    return new Promise(async (resolve, reject) => {
      this.validation = {};
      let public_key;
      let result_string;

      // DNS lookup if not in cache
      if (!this.public_keys[this.record.d]) {
        await this.getDNS(this.record.d, 'mozilla').catch((error) => {
          return reject(
            new ValidationError({
              name: 'DNS_LOOKUP',
              message: 'Querying DoH DNS for public key failed',
              cause: error,
            }),
          );
        });
      }

      // Importkey if not in cache
      if (this.public_keys[this.record.d][this.record.ka]) {
        if (!this.public_keys[this.record.d][this.record.ka].imported_key) {
          public_key = this.public_keys[this.record.d][this.record.ka].imported_key = await this.importPublicKey(
            this.public_keys[this.record.d][this.record.ka].p,
            this.public_keys[this.record.d][this.record.ka].ka,
          ).catch((error) => {
            return reject(
              new ValidationError({
                name: 'KEY_IMPORT_ERROR',
                message: "The Public key couldn't be imported",
                cause: error,
              }),
            );
          });
        } else {
          console.debug('CACHED ---importPublicKey');
          public_key = this.public_keys[this.record.d][this.record.ka].imported_key;
        }
      }

      await SEAL.digest(asset);

      // I would prefer call doubleDigest the "digest-if": A digestif is an alcoholic beverage served after a meal,
      // traditionally believed to aid digestion (even though there is not strong evidence to support this).
      await SEAL.doubleDigest();

      let algorithm;

      let hash;

      switch (this.record.da) {
        case 'sha256':
          hash = 'SHA-256'; // 32 bytes
          break;
        case 'sha384':
          hash = 'SHA-384'; // 48 bytes
          break;
        case 'sha512':
          hash = 'SHA-512'; // 64 bytes
          break;
        case 'sha1':
          hash = 'SHA-1'; // 20 bytes (This algorithm is deprecated by NIST, but still widely used, but don't use this in cryptographic applications)
          break;
        default:
          hash = 'SHA-256';
          break;
      }

      if (this.record.ka == 'rsa') {
        algorithm = 'RSASSA-PKCS1-v1_5'; // only SHA-256?
      }

      if (this.record.ka == 'ec') {
        algorithm = {
          name: 'ECDSA',
          hash: { name: hash },
        };
      }

      if (this.validation.digest2 && this.validation.signature && public_key) {
        await crypto.subtle
          .verify(algorithm, public_key, this.validation.signature, this.validation.digest2)
          .then(async (result) => {
            console.timeEnd('validateSig');
            this.validation.digest2 = await SEAL._digest(this.validation.digest2, this.record.da);
            if (result !== false) {
              result_string = `${asset.mimeType}:[${asset.filename}]\n✅ SEAL record #1 is valid.`;
            } else {
              result_string = `${asset.mimeType}:[${asset.filename}]\n⛔ SEAL record #1 is NOT valid.`;
            }

            if (this.validation.signature_date) {
              result_string = result_string + '\nDate: ' + createDate(this.validation.signature_date);
            }

            let summary = `${result_string}
Signature Algorithm: ${this.record.ka.toUpperCase()}, ${256 * 8} bits
Digest Algorithm: ${this.record.da}
Digest: ${Array.from(new Uint8Array(this.validation.digest1))
              .map((bytes) => bytes.toString(16).padStart(2, '0'))
              .join('')}
Double Digest: ${Array.from(new Uint8Array(this.validation.digest2))
              .map((bytes) => bytes.toString(16).padStart(2, '0'))
              .join('')}
Signed Bytes: ${this.validation.digest_ranges}
Signature Spans: ${this.validation.digest_summary}
Signed By: ${this.record.d} for user ${this.record.id}
Copyright: ${this.record.copyright}
Comment: ${this.record.info}`;

            resolve({ result: result, summary: summary });
          })
          .catch((error) => {
            reject(
              new ValidationError({
                name: 'VALIDATION_GENERAL_ERROR',
                message: "crypto.subtle.verify couldn't process the data",
                cause: error,
              }),
            );
          });
      } else {
        reject(
          new ValidationError({
            name: 'VALIDATION_MISSING_PARAMETERS',
            message: 'Double Digest or Signature or Public key is missing',
          }),
        );
      }
    });
  }

  /**
   *
   *
   * @static
   * @param {ArrayBuffer} data
   * @param {String} [da]
   * @return {*}  {Promise<ArrayBuffer>}
   * @memberof SEAL
   */
  private static async _digest(data: ArrayBuffer, da?: String): Promise<ArrayBuffer> {
    return new Promise(async (resolve) => {
      let algorithm: AlgorithmIdentifier;

      switch (da) {
        case 'sha256':
          algorithm = 'SHA-256'; // 32 bytes
          break;
        case 'sha384':
          algorithm = 'SHA-384'; // 48 bytes
          break;
        case 'sha512':
          algorithm = 'SHA-512'; // 64 bytes
          break;
        case 'sha1':
          algorithm = 'SHA-1'; // 20 bytes (This algorithm is deprecated by NIST, but still widely used, but don't use this in cryptographic applications)
          break;
        default:
          algorithm = 'SHA-256';
          break;
      }
      resolve(await crypto.subtle.digest(algorithm, data));
    });
  }
}

/**
 * Converts a Base64-encoded string to an ArrayBuffer.
 *
 * @param base64 - The Base64-encoded string to convert.
 * @returns The resulting ArrayBuffer.
 */
function base64ToArrayBuffer(base64: string): ArrayBufferLike {
  // Decode the Base64-encoded string into a binary string
  const binaryString: string = atob(base64);

  // Create a Uint8Array to hold the decoded bytes
  const byteArray: Uint8Array = new Uint8Array(binaryString.length);

  // Convert each character in the binary string to a byte in the Uint8Array
  for (let i = 0; i < binaryString.length; i++) {
    byteArray[i] = binaryString.charCodeAt(i);
  }

  // Return the ArrayBuffer representation of the Uint8Array
  return byteArray.buffer;
}

/**
 * Converts a hex string to an ArrayBuffer.
 *
 * @param hex - The hex string to convert.
 * @returns The resulting ArrayBuffer.
 */
function hexToArrayBuffer(hex: string): ArrayBuffer {
  // Ensure the hex string has an even length
  if (hex.length % 2 !== 0) {
    throw new ValidationError({
      name: 'HEX_STRING',
      message: 'Hex string must have an even length',
    });
  }

  // Create a Uint8Array to hold the bytes
  const bytes = new Uint8Array(hex.length / 2);

  // Convert each pair of hex characters to a byte
  for (let i: number = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }

  // Return the ArrayBuffer representation of the Uint8Array
  return bytes.buffer;
}

/**
 * Concatenates two ArrayBuffers.
 *
 * @param buffer1 - The first ArrayBuffer to concatenate.
 * @param buffer2 - The second ArrayBuffer to concatenate.
 * @returns A new ArrayBuffer containing the concatenated data of buffer1 and buffer2.
 */
function concatArrayBuffers(buffer1: ArrayBuffer, buffer2: ArrayBuffer): ArrayBuffer {
  // If buffer1 is null or undefined, return buffer2
  if (!buffer1) {
    return buffer2;
  }
  // If buffer2 is null or undefined, return buffer1
  else if (!buffer2) {
    return buffer1;
  }

  // Create a new Uint8Array to hold the concatenated data
  const concatenatedBuffer = new Uint8Array(buffer1.byteLength + buffer2.byteLength);

  // Set the data from buffer1 into the new Uint8Array
  concatenatedBuffer.set(new Uint8Array(buffer1), 0);

  // Set the data from buffer2 into the new Uint8Array, starting at the end of buffer1's data
  concatenatedBuffer.set(new Uint8Array(buffer2), buffer1.byteLength);

  // Return the ArrayBuffer representation of the concatenated Uint8Array
  return concatenatedBuffer.buffer;
}

/**
 * Creates a Date object from a string in the format YYYYMMDDHHMMSS.sssssssss.
 *
 * @param dateString - The input date string in the format YYYYMMDDHHMMSS.sssssssss.
 * @returns A Date object representing the input date and time.
 */
function createDate(dateString: string): Date {
  // Regular expression to match the components of the date string
  const datePattern = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})\.(\d{0,9})/;

  // Replace the matched components with the format required by the Date constructor
  const formattedDateString = dateString.replace(datePattern, '$1-$2-$3T$4:$5:$6.$7Z');

  // Create and return a new Date object using the formatted date string
  return new Date(formattedDateString);
}
